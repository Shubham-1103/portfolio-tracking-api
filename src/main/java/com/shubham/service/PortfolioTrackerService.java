package com.shubham.service;

import com.shubham.dto.SecurityDto;
import com.shubham.dto.TradeDto;
import com.shubham.enums.TradeType;
import com.shubham.models.Security;
import com.shubham.models.Trade;
import com.shubham.models.TradeValidation;
import com.shubham.repo.SecuritiesRepo;
import com.shubham.repo.TradeRepo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.shubham.util.Util.getWeightedAveragePrice;
import static com.shubham.util.Util.validateTradePriceAndShares;

@Slf4j
@Service
public class PortfolioTrackerService {
    @Autowired
    private SecuritiesRepo securitiesRepo;
    @Autowired
    private TradeRepo tradeRepo;

    /**
     * Gets security corresponding to a ticker.
     *
     * @return security corresponding to a ticker.
     */
    public Optional<SecurityDto> getSecurityByTicker(String ticker) {
        return securitiesRepo.findById(ticker);
    }

    /**
     * calculate total return generated all of the investments.
     * <p>
     * SUM((CURRENT_PRICE[ticker] - AVERAGE_BUY_PRICE[ticker]) * CURRENT_QUANTITY[ticker])
     * </p>
     *
     * @return Total returns based on the security of the user.
     */
    public Optional<BigDecimal> getReturns() {
        return securitiesRepo.findAll().stream()
                .map(this::calculateReturn)
                .reduce(BigDecimal::add);
    }

    /**
     * calculate revenue generated by a security using given formula.
     * <p>
     * (CURRENT_PRICE[ticker] - AVERAGE_BUY_PRICE[ticker]) * CURRENT_QUANTITY[ticker]
     * </p>
     * <p>
     * the current_price for all the stocks is considered as 100.
     *
     * @param securityDto: {@link SecurityDto} consider it as a security information for a ticker.
     * @return the total amount return per security.
     */
    private BigDecimal calculateReturn(SecurityDto securityDto) {
        return BigDecimal.valueOf(100) // Default current price value.
                .subtract(securityDto.getAvgBuyPrice())
                .multiply(BigDecimal.valueOf(securityDto.getShares().longValue()));
    }

    /**
     * Gets a {@link TradeDto} by trade Id.
     *
     * @return {@link TradeDto} by trade Id
     */
    public Optional<TradeDto> getTradeById(Long id) {
        return tradeRepo.findById(id);
    }

    /**
     * Gets all the trades made by the user.
     *
     * @return List of all trades corresponding to the user.
     */
    public List<Trade> getAllTrades() {
        return tradeRepo.findAll().stream()
                .map(Trade::getTradeModel)
                .collect(Collectors.toList());
    }

    /**
     * r
     *
     * @return
     */

    public List<Security> getPortfolioOfUser() {
        return securitiesRepo.findAll()
                .stream()
                .map(Security::getSecurityModel)
                .collect(Collectors.toList());
    }

    //first valid trade.
    public TradeValidation insertToTradeAndSecurity(Trade trade) {
        SecurityDto securityDto = getSecurityDtoFromTrade(trade);
        TradeDto tradeDto = Trade.getTradeDto(trade);
        tradeRepo.save(tradeDto);
        securitiesRepo.save(securityDto);
        return TradeValidation.builder().isValid(true)
                .responseEntity(new ResponseEntity<>(trade, HttpStatus.OK))
                .build();
    }


    private SecurityDto getSecurityDtoFromTrade(Trade trade) {
        Security security = Security.builder()
                .tickerSymbol(trade.getTicker())
                .shares(trade.getShares())
                .avgBuyPrice(trade.getPrice())
                .build();
        return Security.getSecurityDto(security);
    }

    /**
     * This function insert the {@link Trade} to the database and
     * updates the {@link Security} information of the user iff the validation succeeds.
     *
     * @param trade:           {@link Trade} trade that user made.
     * @param oldsecurityDto: {@link SecurityDto} current state of security for the user
     * @return {@link TradeValidation} this is a model that contains if the trade made by the user
     * is valid or not and the Response if the trade is not a valid trade.
     */
    public TradeValidation insertToTradeAndUpdateSecurity(Trade trade, SecurityDto oldsecurityDto) {
        TradeDto tradeDto = Trade.getTradeDto(trade);
        SecurityDto updatedSecurity = getUpdatedSecurity(trade, oldsecurityDto);
        TradeValidation tradeValidation = validateTradePriceAndShares(updatedSecurity);
        if (tradeValidation.isValid()) {
            tradeRepo.save(tradeDto);
            securitiesRepo.save(updatedSecurity);
            tradeValidation.setResponseEntity(new ResponseEntity<>(trade, HttpStatus.OK));
        }
        return tradeValidation;
    }

    /**
     * <p>
     * This function takes the current state of security of the user.
     * build new security Model on the basis of following criteria.
     * </p>
     * <p>
     * if {@link TradeType} == SELL then average buy price will not be affected only shares will be updated.
     * </p>
     * <p>
     * else if {@link TradeType} == BUY then the average price will be calculated as weighted average
     * and also shares will be updated
     * </p>
     * // in case of Selling we need not to update the price only shares will be updated
     * remember basic validation on share is already applied that we can not sell more share than we own.
     *
     * @param trade:               {@link Trade} model on the basis of which operations will be performed
     * @param oldSecurityDetails: {@link SecurityDto} existing security details which needs to be updated after the final operations.
     * @return updated {@link SecurityDto} object that needs to be stored in the DB.
     */
    private SecurityDto getUpdatedSecurity(Trade trade, SecurityDto oldSecurityDetails) {
        Security newSecurity = Security.builder().tickerSymbol(trade.getTicker()).build();
        if (trade.getTradeType() == TradeType.SELL) {
            BigInteger totalRemainingShares = oldSecurityDetails.getShares().subtract(trade.getShares());
            newSecurity.setShares(totalRemainingShares);
            newSecurity.setAvgBuyPrice(oldSecurityDetails.getAvgBuyPrice());
        } else {
            BigInteger totalShares = oldSecurityDetails.getShares().add(trade.getShares());
            newSecurity.setShares(totalShares);
            BigDecimal averagePrice = getWeightedAveragePrice(trade, oldSecurityDetails);
            newSecurity.setAvgBuyPrice(averagePrice);
        }
        return Security.getSecurityDto(newSecurity);
    }
}
