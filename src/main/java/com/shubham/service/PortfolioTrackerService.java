package com.shubham.service;

import com.shubham.client.RestApiClient;
import com.shubham.dto.SecurityDto;
import com.shubham.dto.TradeDto;
import com.shubham.enums.Action;
import com.shubham.enums.TradeType;
import com.shubham.models.QuoteList;
import com.shubham.models.Security;
import com.shubham.models.Trade;
import com.shubham.models.TradeValidation;
import com.shubham.repo.SecuritiesRepo;
import com.shubham.repo.TradeRepo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.shubham.util.Util.getSecurityDtoFromTrade;
import static com.shubham.util.Util.validateTradePriceAndShares;

@Slf4j
@Service
public class PortfolioTrackerService {
    @Autowired
    private SecuritiesRepo securitiesRepo;
    @Autowired
    private TradeRepo tradeRepo;
    @Autowired
    private RestApiClient restApiClient;

    /**
     * Gets security corresponding to a ticker.
     *
     * @return security corresponding to a ticker
     */
    public Optional<Security> getSecurityByTicker(String ticker) {
        return securitiesRepo.findById(ticker).map(Security::getSecurityModel);
    }

    /**
     * calculate total return generated all of the investments.
     * <p>
     * SUM((CURRENT_PRICE[ticker] - AVERAGE_BUY_PRICE[ticker]) * CURRENT_QUANTITY[ticker])
     * </p>
     *
     * @return Total returns based on the security of the user.
     */
    public Optional<BigDecimal> getReturns() {
        return securitiesRepo.findAll().stream()
                .map(this::calculateReturn)
                .reduce(BigDecimal::add);
    }

    /**
     * calculate revenue generated by a security using given formula.
     * <p>
     * (CURRENT_PRICE[ticker] - AVERAGE_BUY_PRICE[ticker]) * CURRENT_QUANTITY[ticker]
     * </p>
     * <p>
     * the current_price for all the stocks is considered as 100.
     *
     * @param securityDto: {@link SecurityDto} consider it as a security information for a ticker.
     * @return the total amount return per security.
     */
    private BigDecimal calculateReturn(SecurityDto securityDto) {
        return getCurrentPrice(securityDto)
                .subtract(securityDto.getAvgBuyPrice())
                .multiply(BigDecimal.valueOf(securityDto.getShares().longValue()));
    }

    /**
     * Gets a {@link TradeDto} by trade Id.
     *
     * @return {@link TradeDto} by trade Id
     */
    public Optional<Trade> getTradeById(Long id) {
        return tradeRepo.findById(id).map(Trade::getTradeModel);
    }

    /**
     * Gets all the trades made by the user.
     *
     * @return List of all trades corresponding to the user.
     */
    public List<Trade> getAllTrades() {
        return tradeRepo.findAll().stream()
                .map(Trade::getTradeModel)
                .collect(Collectors.toList());
    }

    /**
     * @return the list of securities of the user
     */

    public List<Security> getPortfolioOfUser() {
        return securitiesRepo.findAll()
                .stream()
                .map(Security::getSecurityModel)
                .collect(Collectors.toList());
    }

    /**
     * this method insert the {@link TradeDto} and {@link SecurityDto} of the user in the database
     * and returns {@link TradeValidation} that includes the final response from the API
     *
     * @param trade: {@link Trade} trade that user made.
     * @return {@link TradeValidation} this is a model that contains if the trade made by the user
     * is valid or not and the Response if the trade is not a valid trade.
     */
    public TradeValidation insertToTradeAndSecurity(Trade trade) {
        SecurityDto securityDto = getSecurityDtoFromTrade(trade);
        TradeDto tradeDto = Trade.getTradeDto(trade);
        TradeDto updatedTrade = tradeRepo.save(tradeDto);
        securitiesRepo.save(securityDto);
        return TradeValidation.builder().isValid(true)
                .responseEntity(new ResponseEntity<>(Trade.getTradeModel(updatedTrade), HttpStatus.CREATED))
                .build();
    }

    /**
     * This function insert the {@link Trade} to the database and
     * updates the {@link Security} information of the user iff the validation succeeds.
     *
     * @param trade:    {@link Trade} trade that user made.
     * @param security: {@link Security} current state of security for the user
     * @return {@link TradeValidation} this is a model that contains if the trade made by the user
     * is valid or not and the Response if the trade is not a valid trade.
     */
    public TradeValidation insertToTradeAndUpdateSecurity(Trade trade, Security security) {
        TradeDto tradeDto = Trade.getTradeDto(trade);
        updateSecurity(Action.UPDATE, trade, security);
        TradeValidation tradeValidation = validateTradePriceAndShares(security);
        if (tradeValidation.isValid()) {
            TradeDto newTradeDto = tradeRepo.save(tradeDto);
            securitiesRepo.save(Security.getSecurityDto(security));
            tradeValidation.setResponseEntity(new ResponseEntity<>(Trade.getTradeModel(newTradeDto), HttpStatus.OK));
        }
        return tradeValidation;
    }

    /**
     * <p>
     * This function takes the current state of security of the user.
     * build new security Model on the basis of following criteria.
     * </p>
     * <p>
     * if {@link TradeType} == SELL then average buy price will not be affected only shares will be updated.
     * </p>
     * <p>
     * else if {@link TradeType} == BUY then the average price will be calculated as weighted average
     * and also shares will be updated
     * </p>
     * // in case of Selling we need not to update the price only shares will be updated
     * remember basic validation on share is already applied that we can not sell more share than we own.
     *
     * @param trade:    {@link Trade} model on the basis of which operations will be performed
     * @param security: {@link Security} existing security details which needs to be updated after the final operations.
     */
    private void updateSecurity(Action action, Trade trade, Security security) {
        BigDecimal tradeShares = BigDecimal.valueOf(trade.getShares().longValue());
        BigDecimal price = calculateTotalPriceAdjustment(trade, security, tradeShares);
        if (Action.DELETE == action) {
            trade.setTradeType(TradeType.BUY == trade.getTradeType() ? TradeType.SELL : TradeType.BUY);
        }
        if (trade.getTradeType() == TradeType.BUY) {
            security.setShares(security.getShares().add(trade.getShares()));
            security.setTotalPrice(security.getTotalPrice().add(price));
            if (Action.DELETE != action) {
                BigDecimal averagePrice = security.getTotalPrice().divide(
                        BigDecimal.valueOf(security.getShares().intValue()), MathContext.DECIMAL32
                );
                security.setAvgBuyPrice(averagePrice);
            }
        } else {
            security.setShares(security.getShares().subtract(trade.getShares()));
            security.setAvgBuyPrice(security.getAvgBuyPrice());
            security.setTotalPrice(security.getTotalPrice().subtract(price));
            if (BigInteger.ZERO.equals(security.getShares())) {
                security.setAvgBuyPrice(BigDecimal.ZERO);
            } else if (Action.DELETE == action) {
                BigDecimal averagePrice = security.getTotalPrice().divide(
                        BigDecimal.valueOf(security.getShares().intValue()), MathContext.DECIMAL32
                );
                security.setAvgBuyPrice(averagePrice);
            }
        }
    }

    /**
     * @param trade              {@link Trade} model on the basis of which operations will be performed
     * @param oldSecurityDetails {@link Security} existing security details which needs to be updated after the final operations.
     * @param tradeShares        no of shares user make trade of.
     * @return the amount that needs to be added or subtracted on the basis of type of trade made.
     */
    private BigDecimal calculateTotalPriceAdjustment(Trade trade, Security oldSecurityDetails, BigDecimal tradeShares) {
        return TradeType.BUY == trade.getTradeType() ?
                tradeShares.multiply(trade.getPrice()) :
                tradeShares.multiply(oldSecurityDetails.getTotalPrice())
                        .divide(BigDecimal.valueOf(oldSecurityDetails.getShares().longValue()), MathContext.DECIMAL32);
    }

    /**
     * @return Current price of a security by it's ticker.
     */
    private BigDecimal getCurrentPrice(SecurityDto securityDto) {
        String ticker = securityDto.getTickerSymbol();
        QuoteList quoteList = restApiClient.getQuotes(new ArrayList<>(Collections.singleton(ticker)));
        if(quoteList.getData().isEmpty()){
            return BigDecimal.valueOf(100);
        }
        return quoteList.getData().get(0).getPrice();
    }

    public TradeValidation deleteTrade(Long id) {
        Optional<Trade> optionalTrade = tradeRepo.findById(id).map(Trade::getTradeModel);
        if (!optionalTrade.isPresent()) {
            return TradeValidation.builder().isValid(false)
                    .responseEntity(new ResponseEntity<>(String.format("Trade with id %s is not found", id), HttpStatus.NOT_FOUND))
                    .build();
        }
        Trade trade = optionalTrade.get();
        Optional<Security> securityOptional = getSecurityByTicker(trade.getTicker());
        if (!securityOptional.isPresent()) {
            log.error("No security found with ticker : {}", trade.getTicker());
            return TradeValidation.builder().isValid(false)
                    .responseEntity(new ResponseEntity<>(String.format("No security found with ticker : %s", trade.getTicker()), HttpStatus.NOT_FOUND))
                    .build();
        }
        Security security = securityOptional.get();
        updateSecurity(Action.DELETE, trade, security);
        TradeValidation tradeValidation = validateTradePriceAndShares(security);
        if (tradeValidation.isValid()) {
            tradeRepo.deleteById(id);
            if (security.getShares().compareTo(BigInteger.ZERO) == 0) {
                securitiesRepo.delete(Security.getSecurityDto(security));
            } else {
                securitiesRepo.save(Security.getSecurityDto(security));
            }
            tradeValidation.setResponseEntity(new ResponseEntity<>(trade, HttpStatus.OK));
            return tradeValidation;
        }
        return tradeValidation;
    }

}
